from http import HTTPStatus
from typing import Any, Union, cast

import httpx

from ...client import AuthenticatedClient, Client
from ...types import Response, UNSET
from ... import errors


{% for relative in endpoint.relative_imports | sort %}
{{ relative }}
{% endfor %}

{% from "endpoint_macros.py.jinja" import header_params, cookie_params, query_params,
    arguments, client, kwargs, parse_response, docstring, body_to_kwarg %}

{% if endpoint.method.lower() == "head" %}
{% set return_string = "int" %}
{% set parsed_responses = True %}
{% else %}
{% set return_string = endpoint.response_type() %}
{% set parsed_responses = (endpoint.responses | length > 0) and return_string != "Any" %}
{% endif %}

{% if endpoint.name.endswith("_list") and parsed_responses and return_string.startswith("list[") %}
from ...utils import parse_link_header
{% endif %}

def _get_kwargs(
    {{ arguments(endpoint, include_client=False) | indent(4) }}
) -> dict[str, Any]:
    {{ header_params(endpoint) | indent(4) }}

    {{ cookie_params(endpoint) | indent(4) }}

    {{ query_params(endpoint) | indent(4) }}

    _kwargs: dict[str, Any] = {
        "method": "{{ endpoint.method }}",
        {% if endpoint.path_parameters %}
        "url": "{{ endpoint.path }}".format(
        {%- for parameter in endpoint.path_parameters -%}
        {{parameter.python_name}}={{parameter.python_name}},
        {%- endfor -%}
        ),
        {% else %}
        "url": "{{ endpoint.path }}",
        {% endif %}
        {% if endpoint.query_parameters %}
        "params": params,
        {% endif %}
        {% if endpoint.cookie_parameters %}
        "cookies": cookies,
        {% endif %}
    }

{% if endpoint.bodies | length > 1 %}
{% for body in endpoint.bodies %}
    if isinstance(body, {{body.prop.get_type_string() }}):
        {{ body_to_kwarg(body) | indent(8) }}
        {% if body.content_type != "multipart/form-data" %}{# Need httpx to set the boundary automatically #}
        headers["Content-Type"] = "{{ body.content_type }}"
        {% endif %}
{% endfor %}
{% elif endpoint.bodies | length == 1 %}
{% set body = endpoint.bodies[0] %}
    {{ body_to_kwarg(body) | indent(4) }}
    {% if body.content_type != "multipart/form-data" %}{# Need httpx to set the boundary automatically #}
    headers["Content-Type"] = "{{ body.content_type }}"
    {% endif %}
{% endif %}

{% if endpoint.header_parameters or endpoint.bodies | length > 0 %}
    _kwargs["headers"] = headers
{% endif %}
    return _kwargs


def _parse_response(*, client: Union[AuthenticatedClient, Client], response: httpx.Response) -> {{ return_string }}:
{% if endpoint.method.lower() == "head" %}
    if response.status_code == HTTPStatus.OK:
        try:
            return int(response.headers["x-result-count"])
        except KeyError:
            raise errors.UnexpectedStatus(response.status_code, b"Expected 'X-Result-Count' header for HEAD request, but it was not found.", response.url)
        except ValueError:
            count_val = response.headers.get("x-result-count")
            msg = f"Expected 'X-Result-Count' header to be an integer, but got '{count_val}'."
            raise errors.UnexpectedStatus(response.status_code, msg.encode(), response.url)
{% else %}
    if response.status_code == 404:
        raise errors.UnexpectedStatus(response.status_code, response.content, response.url)
    {% for response in endpoint.responses %}
    if response.status_code == {{ response.status_code.value }}:
        {% if parsed_responses %}{% import "property_templates/" + response.prop.template as prop_template %}
        {% if prop_template.construct %}
        {{ prop_template.construct(response.prop, response.source.attribute) | indent(8) }}
        {% elif response.source.return_type == response.prop.get_type_string()  %}
        {{ response.prop.python_name }} = {{ response.source.attribute }}
        {% else %}
        {{ response.prop.python_name }} = cast({{ response.prop.get_type_string() }}, {{ response.source.attribute }})
        {% endif %}
        return {{ response.prop.python_name }}
        {% else %}
        return None
        {% endif %}
    {% endfor %}
{% endif %}
    raise errors.UnexpectedStatus(response.status_code, response.content, response.url)


def _build_response(*, client: Union[AuthenticatedClient, Client], response: httpx.Response) -> Response[{{ return_string }}]:
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content,
        headers=response.headers,
        parsed=_parse_response(client=client, response=response),
    )


def sync_detailed(
    {{ arguments(endpoint) | indent(4) }}
) -> Response[{{ return_string }}]:
    {{ docstring(endpoint, return_string, is_detailed=true) | indent(4) }}

    kwargs = _get_kwargs(
        {{ kwargs(endpoint, include_client=False) }}
    )

    response = client.get_httpx_client().request(
        **kwargs,
    )

    return _build_response(client=client, response=response)

{% if parsed_responses %}
def sync(
    {{ arguments(endpoint) | indent(4) }}
) -> {{ return_string }}:
    {{ docstring(endpoint, return_string, is_detailed=false) | indent(4) }}

    return sync_detailed(
        {{ kwargs(endpoint) }}
    ).parsed
{% endif %}

async def asyncio_detailed(
    {{ arguments(endpoint) | indent(4) }}
) -> Response[{{ return_string }}]:
    {{ docstring(endpoint, return_string, is_detailed=true) | indent(4) }}

    kwargs = _get_kwargs(
        {{ kwargs(endpoint, include_client=False) }}
    )

    response = await client.get_async_httpx_client().request(
        **kwargs
    )

    return _build_response(client=client, response=response)

{% if parsed_responses %}
async def asyncio(
    {{ arguments(endpoint) | indent(4) }}
) -> {{ return_string }}:
    {{ docstring(endpoint, return_string, is_detailed=false) | indent(4) }}

    return (await asyncio_detailed(
        {{ kwargs(endpoint) }}
    )).parsed
{% endif %}

{% if endpoint.name.endswith("_list") and parsed_responses and return_string.startswith("list[") %}
def sync_all(
    {{ arguments(endpoint, skip_pagination=True) | indent(4) }}
) -> {{ return_string }}:
    """Get All Pages
    
     Fetch all pages of paginated results. This function automatically handles pagination
     by following the 'next' link in the Link header until all results are retrieved.
     
     Note: page_size will be set to 100 (the maximum allowed) automatically.
    
    Args:
{% set all_parameters = endpoint.list_all_parameters() %}
{% if all_parameters %}
{% for parameter in all_parameters %}
{% if parameter.name not in ['page', 'page_size'] %}
        {{ parameter.to_docstring() | wordwrap(90) | indent(8) }}
{% endif %}
{% endfor %}
{% endif %}

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        {{ return_string }}: Combined results from all pages
    """
    from urllib.parse import urlencode, parse_qs, urlparse, urlunparse
    
    all_results{{ ":" if return_string.startswith("list[") else " =" }} {{ return_string.replace("list[", "list[") if return_string.startswith("list[") else return_string }} = []
    
    # Get initial request kwargs
    kwargs = _get_kwargs(
        {{ kwargs(endpoint, include_client=False, skip_pagination=True) }}
    )
    
    # Set page_size to maximum
    if "params" not in kwargs:
        kwargs["params"] = {}
    kwargs["params"]["page_size"] = 100
    
    # Make initial request
    response = client.get_httpx_client().request(**kwargs)
    parsed_response = _parse_response(client=client, response=response)
    
    if parsed_response:
        all_results.extend(parsed_response)
    
    # Follow pagination links
    while True:
        link_header = response.headers.get("Link", "")
        links = parse_link_header(link_header)
        
        if "next" not in links:
            break
            
        # Extract page number from next URL
        next_url = links["next"]
        parsed_url = urlparse(next_url)
        next_params = parse_qs(parsed_url.query)
        
        if "page" not in next_params:
            break
        
        # Update only the page parameter, keep all other params
        page_number = next_params["page"][0]
        kwargs["params"]["page"] = page_number
        
        # Fetch next page
        response = client.get_httpx_client().request(**kwargs)
        parsed_response = _parse_response(client=client, response=response)
        
        if parsed_response:
            all_results.extend(parsed_response)
    
    return all_results


async def asyncio_all(
    {{ arguments(endpoint, skip_pagination=True) | indent(4) }}
) -> {{ return_string }}:
    """Get All Pages (Async)
    
     Fetch all pages of paginated results asynchronously. This function automatically handles pagination
     by following the 'next' link in the Link header until all results are retrieved.
     
     Note: page_size will be set to 100 (the maximum allowed) automatically.
    
    Args:
{% set all_parameters = endpoint.list_all_parameters() %}
{% if all_parameters %}
{% for parameter in all_parameters %}
{% if parameter.name not in ['page', 'page_size'] %}
        {{ parameter.to_docstring() | wordwrap(90) | indent(8) }}
{% endif %}
{% endfor %}
{% endif %}

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        {{ return_string }}: Combined results from all pages
    """
    from urllib.parse import urlencode, parse_qs, urlparse, urlunparse
    
    all_results{{ ":" if return_string.startswith("list[") else " =" }} {{ return_string.replace("list[", "list[") if return_string.startswith("list[") else return_string }} = []
    
    # Get initial request kwargs
    kwargs = _get_kwargs(
        {{ kwargs(endpoint, include_client=False, skip_pagination=True) }}
    )
    
    # Set page_size to maximum
    if "params" not in kwargs:
        kwargs["params"] = {}
    kwargs["params"]["page_size"] = 100
    
    # Make initial request
    response = await client.get_async_httpx_client().request(**kwargs)
    parsed_response = _parse_response(client=client, response=response)
    
    if parsed_response:
        all_results.extend(parsed_response)
    
    # Follow pagination links
    while True:
        link_header = response.headers.get("Link", "")
        links = parse_link_header(link_header)
        
        if "next" not in links:
            break
            
        # Extract page number from next URL
        next_url = links["next"]
        parsed_url = urlparse(next_url)
        next_params = parse_qs(parsed_url.query)
        
        if "page" not in next_params:
            break
        
        # Update only the page parameter, keep all other params
        page_number = next_params["page"][0]
        kwargs["params"]["page"] = page_number
        
        # Fetch next page
        response = await client.get_async_httpx_client().request(**kwargs)
        parsed_response = _parse_response(client=client, response=response)
        
        if parsed_response:
            all_results.extend(parsed_response)
    
    return all_results
{% endif %}


