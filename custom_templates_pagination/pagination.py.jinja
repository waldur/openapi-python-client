"""
Pagination utilities for {{ project_name }}.

This module provides utilities to automatically handle pagination for list endpoints
that use page/page_size query parameters using Link headers for pagination detection.
"""

from typing import Callable, TypeVar, Optional, AsyncIterator, Iterator, Union
from dataclasses import dataclass
import re

T = TypeVar('T')


def _parse_link_header(link_header: str) -> dict[str, str]:
    """Parse Link header to extract pagination URLs."""
    links = {}
    if not link_header:
        return links
    
    # Split on commas, but be careful about URLs that might contain commas
    parts = link_header.split(',')
    for part in parts:
        part = part.strip()
        if ';' not in part:
            continue
            
        url_part, rel_part = part.split(';', 1)
        url = url_part.strip(' <>')
        
        # Extract rel value
        rel_match = re.search(r'rel="([^"]+)"', rel_part)
        if rel_match:
            rel = rel_match.group(1)
            links[rel] = url
    
    return links


@dataclass
class PaginationConfig:
    """Configuration for pagination behavior."""
    page_size: int = 100
    max_pages: Optional[int] = None  # Set to limit the number of pages fetched
    start_page: int = 1


class PaginatedEndpoint:
    """
    Wrapper for paginated list endpoints using Link header pagination.
    
    Example usage:
        from {{ package_name }}.api.users import list_users
        from {{ package_name }} import Client
        from {{ package_name }}.pagination import PaginatedEndpoint
        
        client = Client(base_url="https://api.example.com")
        
        # Create a paginated endpoint wrapper
        paginated_users = PaginatedEndpoint(list_users.sync_detailed, list_users.asyncio_detailed)
        
        # Fetch all users
        all_users = paginated_users.fetch_all(client=client)
        
        # Fetch with filters
        active_users = paginated_users.fetch_all(client=client, status="active")
    """
    
    def __init__(self, endpoint_func: Callable, async_func: Callable = None):
        """
        Initialize a paginated endpoint wrapper.
        
        Args:
            endpoint_func: The sync_detailed endpoint function (e.g., list_users.sync_detailed)
            async_func: The asyncio_detailed endpoint function (e.g., list_users.asyncio_detailed)
        """
        self.endpoint_func = endpoint_func
        self.async_func = async_func
        
    def fetch_all(self, config: PaginationConfig = None, **kwargs) -> list:
        """
        Fetch all pages from the endpoint using Link headers.
        
        Args:
            config: Pagination configuration
            **kwargs: Arguments to pass to the endpoint function
            
        Returns:
            List of all items from all pages
        """
        if config is None:
            config = PaginationConfig()
            
        all_items = []
        current_page = config.start_page
        pages_fetched = 0
        
        while True:
            # Check if we've reached the max pages limit
            if config.max_pages and pages_fetched >= config.max_pages:
                break
                
            try:
                # Fetch a page using detailed function to get headers
                response = self.endpoint_func(
                    page=current_page,
                    page_size=config.page_size,
                    **kwargs
                )
            except Exception:
                # If we get an error (like 404), we've likely reached the end
                break
            
            # Extract items from response
            items = response.parsed if hasattr(response, 'parsed') else response
            
            # If no items returned, we've reached the end
            if not items:
                break
                
            # Add items to our collection
            if isinstance(items, list):
                all_items.extend(items)
            else:
                # Single item response, add it and stop
                all_items.append(items)
                break
            
            # Check Link header for next page
            has_next = False
            if hasattr(response, 'headers') and 'link' in response.headers:
                links = _parse_link_header(response.headers['link'])
                has_next = 'next' in links
            
            # If no "next" link, we've reached the end
            if not has_next:
                break
                
            current_page += 1
            pages_fetched += 1
        
        return all_items
    
    async def fetch_all_async(self, config: PaginationConfig = None, **kwargs) -> list:
        """
        Asynchronously fetch all pages from the endpoint using Link headers.
        
        Args:
            config: Pagination configuration
            **kwargs: Arguments to pass to the endpoint function
            
        Returns:
            List of all items from all pages
        """
        if self.async_func is None:
            raise ValueError("Async function not provided")
            
        if config is None:
            config = PaginationConfig()
            
        all_items = []
        current_page = config.start_page
        pages_fetched = 0
        
        while True:
            # Check if we've reached the max pages limit
            if config.max_pages and pages_fetched >= config.max_pages:
                break
                
            try:
                # Fetch a page using detailed function to get headers
                response = await self.async_func(
                    page=current_page,
                    page_size=config.page_size,
                    **kwargs
                )
            except Exception:
                # If we get an error (like 404), we've likely reached the end
                break
            
            # Extract items from response
            items = response.parsed if hasattr(response, 'parsed') else response
            
            # If no items returned, we've reached the end
            if not items:
                break
                
            # Add items to our collection
            if isinstance(items, list):
                all_items.extend(items)
            else:
                # Single item response, add it and stop
                all_items.append(items)
                break
            
            # Check Link header for next page
            has_next = False
            if hasattr(response, 'headers') and 'link' in response.headers:
                links = _parse_link_header(response.headers['link'])
                has_next = 'next' in links
            
            # If no "next" link, we've reached the end
            if not has_next:
                break
                
            current_page += 1
            pages_fetched += 1
        
        return all_items
    
    def iter_pages(self, config: PaginationConfig = None, **kwargs) -> Iterator[list]:
        """
        Iterate over pages one at a time.
        
        This is useful for processing large datasets without loading everything into memory.
        
        Args:
            config: Pagination configuration
            **kwargs: Arguments to pass to the endpoint function
            
        Yields:
            Each page of items
        """
        if config is None:
            config = PaginationConfig()
            
        current_page = config.start_page
        pages_fetched = 0
        
        while True:
            # Check if we've reached the max pages limit
            if config.max_pages and pages_fetched >= config.max_pages:
                break
                
            # Fetch a page
            items = self.endpoint_func(
                page=current_page,
                page_size=config.page_size,
                **kwargs
            )
            
            # If no items returned, we've reached the end
            if not items:
                break
                
            yield items
            
            # If we got fewer items than page_size, we've reached the end
            if isinstance(items, list) and len(items) < config.page_size:
                break
                
            current_page += 1
            pages_fetched += 1
    
    async def iter_pages_async(self, config: PaginationConfig = None, **kwargs) -> AsyncIterator[list]:
        """
        Asynchronously iterate over pages one at a time.
        
        Args:
            config: Pagination configuration
            **kwargs: Arguments to pass to the endpoint function
            
        Yields:
            Each page of items
        """
        if self.async_func is None:
            raise ValueError("Async function not provided")
            
        if config is None:
            config = PaginationConfig()
            
        current_page = config.start_page
        pages_fetched = 0
        
        while True:
            # Check if we've reached the max pages limit
            if config.max_pages and pages_fetched >= config.max_pages:
                break
                
            # Fetch a page
            items = await self.async_func(
                page=current_page,
                page_size=config.page_size,
                **kwargs
            )
            
            # If no items returned, we've reached the end
            if not items:
                break
                
            yield items
            
            # If we got fewer items than page_size, we've reached the end
            if isinstance(items, list) and len(items) < config.page_size:
                break
                
            current_page += 1
            pages_fetched += 1


def paginate(sync_func: Callable, async_func: Callable = None) -> PaginatedEndpoint:
    """
    Convenience function to create a PaginatedEndpoint.
    
    Args:
        sync_func: The sync_detailed endpoint function
        async_func: The asyncio_detailed endpoint function (optional)
        
    Returns:
        PaginatedEndpoint instance
        
    Example:
        from {{ package_name }}.api.users import list_users
        from {{ package_name }}.pagination import paginate
        
        paginated_users = paginate(list_users.sync_detailed, list_users.asyncio_detailed)
        all_users = paginated_users.fetch_all(client=client)
    """
    return PaginatedEndpoint(sync_func, async_func)